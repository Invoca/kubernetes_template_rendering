# frozen_string_literal: true

require_relative "../../lib/kubernetes_template_rendering/template"
require_relative "../../lib/kubernetes_template_rendering/erb_template"
require_relative "../../lib/kubernetes_template_rendering/jsonnet_template"

RSpec.describe KubernetesTemplateRendering::Template do
  let(:path)               { "/tmp/foo.erb" }
  let(:hash)               { { "a" => "value1", "b" => "value2" } }
  let(:erb)                { "<%= a %> <%= b %>" }
  let(:source_repo)        { nil }
  let(:variable_overrides) { {} }
  let(:klass)              { KubernetesTemplateRendering::ErbTemplate }

  describe "#render" do
    subject(:render_template) { template.render}

    let(:return_erb_on_file_read) { expect(File).to receive(:read).with(path).and_return(erb) }
    let(:template)                { klass.new(path, hash, source_repo:, variable_overrides:) }

    it "reads the template and renders the ERB template using the provided hash" do
      return_erb_on_file_read
      expect(render_template).to eq("value1 value2")
    end

    context "with yaml.erb files" do
      let(:path) { "/tmp/foo.yaml.erb" }
      let(:erb) { { b: "<%= b %>", a: "<%= a %>" }.to_yaml }

      it "adds a magic autogenerated comment with warning to not modify" do
        return_erb_on_file_read
        expect(render_template).to include("# WARNING: DO NOT EDIT THIS FILE!")
        expect(render_template).to include("# This file is autogenerated from #{path}")
      end

      context "path includes /templates/" do
        let(:path) { "/tmp/templates/call-imports/namespace.yaml.erb" }
        it "uses a file path starting with the template dir for the comment" do
          return_erb_on_file_read
          expect(render_template).to include("# This file is autogenerated from /tmp/templates/call-imports/namespace.yaml.erb")
        end
      end

      context "when a source repo is provided" do
        let(:source_repo) { "Invoca/repo" }
        it "uses the source repo to generate a github link to the template location" do
          return_erb_on_file_read
          expect(render_template).to include("# This file is autogenerated from https://github.com/Invoca/repo/blob/-/tmp/foo.yaml.erb")
        end
      end

      context "when variable overrides are provided" do
        let(:variable_overrides) { { "deploySha" => "override" } }
        it "adds a comment with the variable overrides used" do
          return_erb_on_file_read
          expect(render_template).to include("# Variable overrides used: {\"deploySha\":\"override\"}")
        end
      end

      it "reads the template, renders the ERB template, and sorts the keys" do
        return_erb_on_file_read
        expected_json_doc = { a: "value1", b: "value2" }
        expect(YAML.load(render_template)).to eq(expected_json_doc)
      end

      context "with deep nested yaml" do
        let(:erb) do
          {
            resource: {
              env_variables: [{ value: "<%= a %>", key: "a" },
                              { key: "b", value: "<%= b %>" }],
              container: {
                name: "consumer",
                image: "a13da94ka"
              }
            },
            api_version: "test"
          }.to_yaml
        end
        it "sorts all nested keys alphabetically while still rendering the erb" do
          return_erb_on_file_read
          expected_json_doc = {
            api_version: "test",
            resource: {
              container: {
                image: "a13da94ka",
                name: "consumer"
              },
              env_variables: [{ key: "a", value: "value1" },
                              { key: "b", value: "value2" }]
            }
          }
          expect(YAML.load(render_template)).to eq(expected_json_doc)
        end
      end
    end

    context "for .jsonnet files" do
      let(:klass) { KubernetesTemplateRendering::JsonnetTemplate }
      let(:path) { File.expand_path("../fixtures/resource_set/app-namespace.jsonnet", __dir__) }
      let(:hash) { { owner: "omega", namespace: "call-imports" } }

      it "adds magic comment about being autogenerated and has a warning to not edit" do
        expect(render_template).to include("# WARNING: DO NOT EDIT THIS FILE!")
        expect(render_template).to include("# This file is autogenerated from #{path}")
      end

      it "renders the file into YAML with the appropriate values applied" do
        expected_json_doc = {
          "apiVersion" => "v1",
          "kind" => "Namespace",
          "metadata" => {
            "name" => "app-call-imports",
            "namespace" => "call-imports",
            "labels" => {
              "owner" => "omega"
            }
          },
          "spec" => {
            "finalizers" => ["kubernetes"]
          }
        }
        expect(YAML.load(render_template)).to eq(expected_json_doc)
      end

      context "with flat multi file rendering" do
        let(:path) { File.expand_path("../fixtures/jsonnet/multi_file_example.jsonnet", __dir__) }
        let(:hash) { { name: "pnapi", container_name: "app", container_sha: "abcd1234" } }

        it "renders the jsonnet file into a hash of file names to yaml to be written to the file" do
          expected_hash = {
            "service.yaml" => {
              "name" => "pnapi-service",
              "container" => {
                "name" => "app",
                "sha" => "abcd1234"
              }
            },
            "pnapi-service-monitor.yaml" => {
              "name" => "pnapi",
              "selector" => {
                "matchLabels" => {
                  "app" => "pnapi"
                }
              }
            }
          }
          expected_hash.each do |file_name, yaml|
            expect(YAML.load(render_template[file_name])).to eq(yaml)
          end
        end

        it "adds magic comments to each yaml file rendered" do
          expect(render_template["service.yaml"]).to include("# WARNING: DO NOT EDIT THIS FILE!")
          expect(render_template["service.yaml"]).to include("# This file is autogenerated from #{path}")
          expect(render_template["pnapi-service-monitor.yaml"]).to include("# WARNING: DO NOT EDIT THIS FILE!")
          expect(render_template["pnapi-service-monitor.yaml"]).to include("# This file is autogenerated from #{path}")
        end
      end

      context "with nested multi file rendering" do
        let(:path) { File.expand_path("../fixtures/jsonnet/nested_multi_file_example.jsonnet", __dir__) }
        let(:hash) { { name: "pnapi", container_name: "app", container_sha: "abcd1234" } }

        it "flattens the nested multi file renders into a single hash of file names to yaml output" do
          expected_hash = {
            "service.yaml" => {
              "name" => "pnapi-service",
              "container" => {
                "name" => "app",
                "sha" => "abcd1234"
              }
            },
            "pnapi-service-monitor.yaml" => {
              "name" => "pnapi",
              "selector" => {
                "matchLabels" => {
                  "app" => "pnapi"
                }
              }
            },
            "pnapi-user-role.yaml" => {
              "kind" => "Role",
              "name" => "pnapi-user",
              "rules" => []
            },
            "pnapi-user-rolebinding.yaml" => {
              "kind" => "RoleBinding",
              "roleRef" => {
                "name" => "pnapi-user",
                "kind" => "Role"
              },
              "subjects" => []
            }
          }

          expected_hash.each do |file_name, yaml|
            expect(YAML.load(render_template[file_name])).to eq(yaml)
          end
        end
      end
    end
  end

  describe "#snippet" do
    subject(:template) { klass.new(path, hash) }
    let(:erb) { "<%= a %> <%= b %> <%= snippet 'something' %>" }
    let(:snippet_erb) { "  <%= a %>=<%= b %>  " }

    it "reads the snippet in the same directory and renders it as an ERB template" do
      expect(File).to receive(:read).with(path).and_return(erb)
      expect(File).to receive(:read).with("/tmp/something").and_return(snippet_erb)
      expect(template.render).to eq("value1 value2   value1=value2  ")
    end
  end

  describe ".render" do
    subject(:template_render) { klass.render(path, hash) }

    it "creates the template object and calls render on it" do
      template_double = instance_double(klass)
      expect(klass).to(
        receive(:new)
          .with(path, hash, source_repo:, variable_overrides:)
          .and_return(template_double)
      )
      expect(template_double).to receive(:render)
      template_render
    end
  end
end
